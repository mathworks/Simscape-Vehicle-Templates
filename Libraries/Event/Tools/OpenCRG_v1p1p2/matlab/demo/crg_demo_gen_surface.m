function [] = crg_demo_gen_surface()
% CRG_DEMO_GEN_SURFACE CRG demo to generate a surface crg file.
%   CRG_DEMO_GEN_SURFACE demonstrates how a surface crg file can be
%   generated. It uses one of the OpenCRG data samples as measurement
%   data source.
%   In the first step, the refline.crg file has to be generated by
%   calling CRG_DEMO_GEN_REFLINE.
%   In this second step, we use the just generated refline to evaluate the
%   measurement data at the given CRG elevation grid points. This step is
%   segmented into pieces of 5000 cross cuts, which are written to files.
%   Then, the CRG segments are loaded, concatenated, and written to the
%   resulting suface.crg file in the current directory.
%   To keep maximum elevation grid accuracy, the mean elevation of
%   all cross cuts is used to generate a first approach for the refline
%   slope, resulting in "small" elevation values in the CRG elevation grid.
%   In the third step, the surface.crg file has to be finally prepared by
%   CRG_GEN_TARGET for later use
%
%   Example:
%   crg_demo_gen_surface       runs this demo to generate "surface.crg"
%
%   See also CRG_INTRO.

%   Copyright 2005-2010 OpenCRG - Daimler AG - Jochen Rauh
%
%   Licensed under the Apache License, Version 2.0 (the "License");
%   you may not use this file except in compliance with the License.
%   You may obtain a copy of the License at
%
%       http://www.apache.org/licenses/LICENSE-2.0
%
%   Unless required by applicable law or agreed to in writing, software
%   distributed under the License is distributed on an "AS IS" BASIS,
%   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%   See the License for the specific language governing permissions and
%   limitations under the License.
%
%   More Information on OpenCRG open file formats and tools can be found at
%
%       http://www.opencrg.org
%
%   $Id: crg_demo_gen_surface.m 184 2010-09-22 07:41:39Z jorauh $

%% use CRG demo data set as raw measurement data

crgmeas = crg_read('../crg-bin/country_road.crg');
crgmeas.mods = struct;
crgmeas.opts.bdmu = 0;
crgmeas.opts.bdmv = 0;

%% set processing parameters and options

lshow = 1;  % show results [0 1]
du0 = 5000; % number of cross cuts for intermediate files

altz0 = crgmeas.head.abeg-crgmeas.head.zbeg; % WGS84 altitude for z_measurement = 0

vmin = -1;      % right edge of road
vmax = +1;      % left  edge of road
vinc = 0.01;    % lateral grid spacing

smax = 0.5; % maximal primary slope (set smax=0 to avoid slope extraction)
bmax = 0.5; % maximal primary banking (set bmax=0 to avoid banking extraction)

%% use CRG refline generated by crg_demo_gen_refline

crgrefl0 = crg_read('refline.crg');
nu0 = round((crgrefl0.head.uend-crgrefl0.head.ubeg)/crgrefl0.head.uinc) + 1;
uinc = crgrefl0.head.uinc;

%% first measurement evaluation along reference line to look for start/end

fprintf(1, 'searching along refline for valid measurements on cross cut [%d:%d]\n', 1, nu0);

puv(:,1) = crgrefl0.head.ubeg + crgrefl0.head.uinc*[0:nu0-1]'; % PUV along refline
puv(:,2) = 0;
[pxy, crgrefl] = crg_eval_uv2xy(crgrefl0, puv); % PXY along refline

[pz , crgmeas] = crg_eval_xy2z(crgmeas, pxy); % PZ measurements along refline

valid = ~isnan(pz);
ibeg = find(valid, 1, 'first');
iend = find(valid, 1, 'last');

fprintf(1, 'valid measurements at refline center available on cross cut [%d:%d]\n\n', ibeg, iend);

%% second mesurement evaluation over all segments with full cross cuts

iu0=[ibeg 0];
is0 = 0;
nlin = 0;
npts = 0;
zref = mean(pz(valid)); % use mean elevation as default

while iu0(2) < iend
    iu0(2) = iu0(1)+ ceil(1.1*du0); % allow 10% oversize
    if iu0(2) >= iend
        iu0(2) = iend;
    else
        iu0(2) = iu0(1) + du0-1;
    end
    is0 = is0 + 1;

    fprintf(1, 'running on segment %d cross cut [%d:%d] ...\n', is0, iu0(1), iu0(2));

    %% cut relevant refline part

    crgrefl = crg_cut_iuiv(crgrefl0, iu0);

    %% copy refline parts to surface CRG struct

    crgsurf.u = crgrefl.u;
    crgsurf.p = crgrefl.p;

    crgsurf.head.ubeg = crgrefl.head.ubeg;
    crgsurf.head.uend = crgrefl.head.uend;
    crgsurf.head.uinc = crgrefl.head.uinc;
    crgsurf.head.xbeg = crgrefl.head.xbeg;
    crgsurf.head.ybeg = crgrefl.head.ybeg;
    crgsurf.head.xend = crgrefl.head.xend;
    crgsurf.head.yend = crgrefl.head.yend;
    crgsurf.head.pbeg = crgrefl.head.pbeg;
    crgsurf.head.pend = crgrefl.head.pend;

    if isfield(crgrefl.head, 'ebeg'), crgsurf.head.ebeg = crgrefl.head.ebeg; end
    if isfield(crgrefl.head, 'nbeg'), crgsurf.head.nbeg = crgrefl.head.nbeg; end
    if isfield(crgrefl.head, 'eend'), crgsurf.head.eend = crgrefl.head.eend; end
    if isfield(crgrefl.head, 'nend'), crgsurf.head.nend = crgrefl.head.nend; end

    %% define lateral grid

    crgsurf.head.vmin = vmin;
    crgsurf.head.vmax = vmax;
    crgsurf.head.vinc = vinc;

    crgsurf.v = crgsurf.head.vmin:crgsurf.head.vinc:crgsurf.head.vmax;

    %% allocate elevation grid

    nu = round((crgsurf.head.uend-crgsurf.head.ubeg)/crgsurf.head.uinc) + 1;
    nv = length(crgsurf.v);

    crgsurf.z = zeros(nu, nv  , 'single');
    crgsurf.s = zeros( 1, nu-1, 'single');
    crgsurf.b = zeros( 1, nu  , 'single');

    %% prepare evaluation

    puv = zeros(nv, 2);
    puv(:, 2) = crgsurf.v;

    %% fill elevation grid

    for iu = 1:nu
        puv(:, 1) = crgrefl.head.ubeg + (iu-1)*crgrefl.head.uinc; % cross cut PUV
        [pxy, crgrefl] = crg_eval_uv2xy(crgrefl, puv);            % cross cut PXY

        [pz , crgmeas] = crg_eval_xy2z(crgmeas, pxy);     % measurements at PXY

        valid = ~isnan(pz);

        if sum(valid) == 0
            warning('CRG:genWarning', 'measurement with full NaN cross section at iu = %d', iu0(1)+iu-1)
            nlin = nlin + 1;
            pz(1) = zref; % set zero replacement in column 1 (right side of road)
            valid(1) = 1;
        end

        % linear regression on cross cut: least squares fit
        zreg = [crgsurf.v(valid)' ones(sum(valid),1)]\pz(valid);
        zabs = zreg(2);
        zlin = zreg(1);

        % set slope and banking
        if iu == 1
            if smax ~= 0
                zref = zabs;
            end
            zbeg = zref;
        else
            crgsurf.s(iu-1) = single(min(max(-smax, (zabs-zref)/uinc), smax));
            zref = zref + uinc*double(crgsurf.s(iu-1));
        end
        crgsurf.b(iu) = min(max(-bmax, zlin), bmax);

        % fill missing measurement values
        r = find(valid, 1, 'first');
        l = find(valid, 1, 'last');
        while sum(valid(r:l)) ~= l-r+1
            ir = find(~valid(r:l), 1, 'first') + ( r-1); % pointer to first NaN inside data
            il = find(valid(ir:l), 1, 'first') + (ir-2); % pointer to last NaN in sequence
            warning('CRG:genWarning', 'measurment with NaN [%d:%d] inside valid data [%d:%d] at iu = %d', ir, il, r, l, iu0(1)+iu-1)

            pz(ir:il) = interp1([puv(ir-1,2) puv(il+1,2)], [pz(ir-1), pz(il+1)], puv(ir:il, 2));
            valid(ir:il) = 1;
            npts = npts + il-ir+1;
        end

        % apply slope and banking
        pz = pz - zref; % substract current refline elevation
        pz = pz - crgsurf.v'*double(crgsurf.b(iu)); % substract banking

        crgsurf.z(iu, :) = single(pz');       % save to elevation grid
    end
    zend = zref;

    %% define and store refline z and altitude

    crgsurf.head.zbeg = zbeg;
    crgsurf.head.zend = zend;
    crgsurf.head.abeg = altz0 + zbeg;
    crgsurf.head.aend = altz0 + zend;

    %% check surface CRG data set

    crgsurf = crg_check(crgsurf);
    if ~isfield(crgsurf, 'ok')
        error('CRG:checkError', 'check of DATA was not completely successful')
    end

    %% write surface CRG data set

    crgsurf.filenm = sprintf('surface_%04d.crg', is0);
    crgsurf.ct{1}  = sprintf('demo segment generated by %s at %s', mfilename, datestr(now, 31));
    crg_write(crgsurf, crgsurf.filenm);

    %% cleanup, update segment start

    clear crgsurf
    iu0(1) = iu0(2) - 1;
end

fprintf(1, 'all %d segments are written.\n', is0);
if nlin > 0
    fprintf(1, '%d full NaN cross cuts occured, please check\n', nlin);
end
if npts > 0
    fprintf(1, '%d NaN points were replaced by linear interpolation inside the cross cut, please check\n', npts);
end
fprintf(1, '\n');

%% concatenate all files

for i = 1:is0
    fprintf(1, 'concatenating segment %d ...\n', i);
    crgsurfi = crg_read(sprintf('surface_%04d.crg', i));
    ceps = crgsurfi.opts.ceps;
    ulen = crgsurfi.head.uend-crgsurfi.head.ubeg;

    if i == 1
        crgsurf = crgsurfi;
    else
        [crgsurf roffi]= crg_append(crgsurf, crgsurfi);
        if sqrt(roffi.rlox^2 + roffi.rloy^2 + roffi.rloz^2) > ceps*ulen
            warning('CRG:genWarning', 'inexpected position offset xyz=[%d %d %d]m applied by crg_append', roffi.rlox, roffi.rloy, roffi.rloz)
        end

        if abs(atan2(sin(roffi.rlop), cos(roffi.rlop))) > ceps*pi
            warning('CRG:genWarning', 'inexpected rotation offset phi=[%d]deg applied by crg_append', roffi.rlop*180/pi)
        end
    end
end

%% write surface CRG data set

crgsurf.filenm = 'surface.crg';
crgsurf.ct{1}  = sprintf('demo surface generated by %s at %s', mfilename, datestr(now, 31));
crg_write(crgsurf, crgsurf.filenm);

fprintf(1, '\nCRG surface file %s is written.\n', crgsurf.filenm);

%% show what we have got so far ...

if lshow
    crgsurf = crg_show(crgsurf);
    crg_wgs84_crg2html(crgsurf, 'surface.html');
    web('surface.html', '-browser');
end
